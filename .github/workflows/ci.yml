name: ðŸ”§ CI

# Caching Strategy for Self-Hosted Runners:
# - Each matrix job gets completely isolated cache directories using run_id + run_attempt + matrix values
# - GOCACHE: ~/.cache/go-build-{goos}-{goarch}-{run_id}-{run_attempt}
# - GOMODCACHE: ~/go/pkg/mod-{goos}-{goarch}-{run_id}-{run_attempt}
# - GOPATH: ~/go-{goos}-{goarch}-{run_id}-{run_attempt}
# - This prevents simultaneous matrix jobs from interfering with each other
# - Cleanup removes old isolated directories while preserving current run caches

on:
  push:
    branches: ["**"] # Run on all branches
    tags: ["v*"] # Run on version tags for releases
  pull_request:
    branches: [main, develop]
  workflow_dispatch:

env:
  GO_VERSION: "1.24"
  CACHE_VERSION: "v3" # Increment to invalidate all caches
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

permissions:
  contents: write # Required for creating releases
  packages: write # Required for container registry
  security-events: write # Required for security scanning
  actions: read
  checks: write
  pull-requests: write

jobs:
  # Pre-flight checks and setup
  preflight:
    name: ðŸ” Pre-flight Checks
    runs-on: ubuntu-latest
    outputs:
      go-version: ${{ steps.setup.outputs.go-version }}
      cache-key: ${{ steps.setup.outputs.cache-key }}
      is-release: ${{ steps.setup.outputs.is-release }}
      version: ${{ steps.setup.outputs.version }}
    steps:
      - name: ðŸ“¥ Checkout code
        uses: actions/checkout@v5
        with:
          fetch-depth: 0 # Full history for versioning

      - name: ðŸ”§ Setup variables
        id: setup
        run: |
          echo "go-version=${{ env.GO_VERSION }}" >> $GITHUB_OUTPUT
          echo "cache-key=${{ env.CACHE_VERSION }}-${{ runner.os }}-go-${{ env.GO_VERSION }}-${{ hashFiles('**/go.sum') }}" >> $GITHUB_OUTPUT

          # Check if this is a release
          if [[ $GITHUB_REF == refs/tags/v* ]]; then
            echo "is-release=true" >> $GITHUB_OUTPUT
            echo "version=${GITHUB_REF#refs/tags/}" >> $GITHUB_OUTPUT
          else
            echo "is-release=false" >> $GITHUB_OUTPUT
            echo "version=dev-$(date +%Y%m%d)-$(echo $GITHUB_SHA | cut -c1-8)" >> $GITHUB_OUTPUT
          fi

      - name: ðŸ“Š Job Summary
        run: |
          echo "## ðŸ” Pre-flight Summary" >> $GITHUB_STEP_SUMMARY
          echo "| Property | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|----------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| Go Version | ${{ env.GO_VERSION }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Is Release | ${{ steps.setup.outputs.is-release }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Version | ${{ steps.setup.outputs.version }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Cache Key | ${{ steps.setup.outputs.cache-key }} |" >> $GITHUB_STEP_SUMMARY

  # Build and test matrix
  test:
    name: ðŸ§ª Test & Build
    needs: preflight
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        include:
          - os: ubuntu-latest
            goos: linux
            goarch: amd64
            label: "Linux AMD64"
          - os: ubuntu-latest
            goos: linux
            goarch: arm64
            label: "Linux ARM64"
          - os: ubuntu-latest
            goos: windows
            goarch: amd64
            label: "Windows AMD64"
          - os: ubuntu-latest
            goos: darwin
            goarch: amd64
            label: "macOS AMD64"
          - os: ubuntu-latest
            goos: darwin
            goarch: arm64
            label: "macOS ARM64"

    steps:
      - name: ðŸ§¹ Cleanup workspace (self-hosted)
        run: |
          echo "ðŸ§¹ Cleaning up workspace for self-hosted runner..."
          # Remove any previous build artifacts from workspace
          rm -rf bin/ coverage.* *.prof || true

          # Clean up old isolated Go caches (keep current run)
          CURRENT_RUN="${{ github.run_id }}-${{ github.run_attempt }}"

          # Clean up old build caches (older than 1 day)
          if [ -d ~/.cache ]; then
            find ~/.cache -type d -name "go-build-*" -not -name "*${CURRENT_RUN}*" -mtime +1 -exec rm -rf {} + 2>/dev/null || true
          fi

          # Clean up old module caches (older than 1 day)
          if [ -d ~/go ]; then
            find ~/go -type d -name "pkg" -path "*/mod-*" -not -path "*${CURRENT_RUN}*" -mtime +1 -exec rm -rf {} + 2>/dev/null || true
            find ~/go -type d -name "go-*" -not -name "*${CURRENT_RUN}*" -mtime +1 -exec rm -rf {} + 2>/dev/null || true
          fi

      - name: ðŸ“¥ Checkout code
        uses: actions/checkout@v5
        with:
          fetch-depth: 0

      - name: ðŸ”§ Set up Go
        uses: actions/setup-go@v6
        with:
          go-version: ${{ needs.preflight.outputs.go-version }}
          cache: false # We'll handle caching manually for better control

      - name: ðŸ”§ Configure Go cache directories
        run: |
          # Create unique workspace identifier for this matrix job
          MATRIX_ID="${{ matrix.goos }}-${{ matrix.goarch }}-${{ github.run_id }}-${{ github.run_attempt }}"

          # Set unique cache directories for this matrix job
          export GOCACHE="$HOME/.cache/go-build-${MATRIX_ID}"
          export GOMODCACHE="$HOME/go/pkg/mod-${MATRIX_ID}"
          export GOPATH="$HOME/go-${MATRIX_ID}"
          export GOBIN="${GOPATH}/bin"

          echo "GOCACHE=${GOCACHE}" >> $GITHUB_ENV
          echo "GOMODCACHE=${GOMODCACHE}" >> $GITHUB_ENV
          echo "GOPATH=${GOPATH}" >> $GITHUB_ENV
          echo "GOBIN=${GOBIN}" >> $GITHUB_ENV
          echo "MATRIX_ID=${MATRIX_ID}" >> $GITHUB_ENV

          mkdir -p "${GOCACHE}" "${GOMODCACHE}" "${GOPATH}" "${GOBIN}"

          # Add isolated GOBIN to PATH
          echo "${GOBIN}" >> $GITHUB_PATH

          echo "âœ… Go cache directories configured for matrix job ${MATRIX_ID}:"
          echo "  GOCACHE: ${GOCACHE}"
          echo "  GOMODCACHE: ${GOMODCACHE}"
          echo "  GOPATH: ${GOPATH}"
          echo "  GOBIN: ${GOBIN}"

      - name: ðŸ’¾ Cache Go modules and build cache
        uses: actions/cache@v4
        id: go-cache
        with:
          path: |
            ~/go/pkg/mod-${{ matrix.goos }}-${{ matrix.goarch }}-${{ github.run_id }}-${{ github.run_attempt }}
            ~/.cache/go-build-${{ matrix.goos }}-${{ matrix.goarch }}-${{ github.run_id }}-${{ github.run_attempt }}
            ~/go-${{ matrix.goos }}-${{ matrix.goarch }}-${{ github.run_id }}-${{ github.run_attempt }}
          key: ${{ needs.preflight.outputs.cache-key }}-${{ matrix.goos }}-${{ matrix.goarch }}-${{ github.run_id }}-${{ github.run_attempt }}
          restore-keys: |
            ${{ env.CACHE_VERSION }}-${{ runner.os }}-go-${{ env.GO_VERSION }}-${{ matrix.goos }}-${{ matrix.goarch }}-
            ${{ env.CACHE_VERSION }}-${{ runner.os }}-go-${{ env.GO_VERSION }}-
            ${{ env.CACHE_VERSION }}-${{ runner.os }}-go-

      - name: ðŸ”§ Install make (if needed)
        run: |
          if ! command -v make &> /dev/null; then
            echo "Installing make..."
            sudo apt-get update && sudo apt-get install -y make
          else
            echo "âœ… make is already installed: $(make --version | head -1)"
          fi

      - name: ðŸ”§ Install development tools
        run: |
          echo "ðŸ”§ Installing required development tools to isolated GOBIN..."

          # Install golangci-lint to isolated GOBIN
          if ! command -v golangci-lint &> /dev/null; then
            echo "Installing golangci-lint to ${GOBIN}..."
            curl -sSfL https://raw.githubusercontent.com/golangci/golangci-lint/master/install.sh | sh -s -- -b "${GOBIN}" latest
          fi

          # Install gosec to isolated GOBIN
          if ! command -v gosec &> /dev/null; then
            echo "Installing gosec to ${GOBIN}..."
            go install github.com/securego/gosec/v2/cmd/gosec@latest
          fi

          # Install goimports to isolated GOBIN
          if ! command -v goimports &> /dev/null; then
            echo "Installing goimports to ${GOBIN}..."
            go install golang.org/x/tools/cmd/goimports@latest
          fi

          echo "âœ… Development tools installed to ${GOBIN}"
          echo "Installed tools:"
          ls -la "${GOBIN}" || echo "No tools found in ${GOBIN}"

      - name: ðŸ“¦ Download dependencies
        run: |
          echo "ðŸ“¦ Downloading Go dependencies..."
          make deps

      - name: ðŸ§¹ Clean previous builds
        run: |
          echo "ðŸ§¹ Cleaning previous build artifacts..."
          make clean

      - name: ðŸ”¨ Build applications
        env:
          GOOS: ${{ matrix.goos }}
          GOARCH: ${{ matrix.goarch }}
        run: |
          echo "ðŸ”¨ Building applications for ${{ matrix.label }}..."
          make build

          # List built binaries
          echo "ðŸ“¦ Built binaries:"
          ls -la bin/ || echo "No binaries found"

      # Only run tests, linting, and coverage on native platform (linux/amd64)
      - name: ðŸ§ª Run tests
        if: matrix.goos == 'linux' && matrix.goarch == 'amd64'
        run: |
          echo "ðŸ§ª Running tests..."
          make test

      - name: ðŸ“Š Generate test coverage
        if: matrix.goos == 'linux' && matrix.goarch == 'amd64'
        run: |
          echo "ðŸ“Š Generating test coverage..."
          make test-coverage

      - name: ðŸ” Run linter
        if: matrix.goos == 'linux' && matrix.goarch == 'amd64'
        run: |
          echo "ðŸ” Running linter..."
          make lint

      - name: ðŸ”Ž Run go vet
        if: matrix.goos == 'linux' && matrix.goarch == 'amd64'
        run: |
          echo "ðŸ”Ž Running go vet..."
          make vet

      - name: ðŸ”’ Run security scan
        if: matrix.goos == 'linux' && matrix.goarch == 'amd64'
        run: |
          echo "ðŸ”’ Running security scan..."
          make security

      - name: ðŸ“¤ Upload test artifacts
        if: matrix.goos == 'linux' && matrix.goarch == 'amd64'
        uses: actions/upload-artifact@v4
        with:
          name: test-results-${{ matrix.goos }}-${{ matrix.goarch }}
          path: |
            coverage.out
            coverage.html
          retention-days: 30
          if-no-files-found: warn

      - name: ðŸ“¤ Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: binaries-${{ matrix.goos }}-${{ matrix.goarch }}
          path: |
            bin/
          retention-days: 30
          if-no-files-found: error

      - name: ðŸ§¹ Post-job cleanup (self-hosted)
        if: always()
        run: |
          echo "ðŸ§¹ Post-job cleanup for self-hosted runner..."

          # Clean up temporary files
          rm -rf /tmp/go-* 2>/dev/null || true

          # Clean up old build artifacts (keep current run)
          find . -name "*.prof" -mtime +1 -delete 2>/dev/null || true

          # Clean up this job's isolated cache directories after a delay to allow for potential retries
          MATRIX_ID="${{ matrix.goos }}-${{ matrix.goarch }}-${{ github.run_id }}-${{ github.run_attempt }}"
          echo "Scheduling cleanup of isolated cache directories for ${MATRIX_ID}..."

          # Remove isolated directories for this specific matrix job
          # Only clean up if this is not the latest attempt or run
          if [ "${{ github.run_attempt }}" != "1" ] || [ "${{ strategy.job-index }}" == "${{ strategy.job-total }}" ]; then
            rm -rf "$HOME/.cache/go-build-${MATRIX_ID}" 2>/dev/null || true
            rm -rf "$HOME/go/pkg/mod-${MATRIX_ID}" 2>/dev/null || true  
            rm -rf "$HOME/go-${MATRIX_ID}" 2>/dev/null || true
          fi

  # Dependency analysis and SBOM generation
  dependency-analysis:
    name: ðŸ” Dependency Analysis & SBOM
    needs: preflight
    runs-on: ubuntu-latest
    permissions:
      contents: read
      security-events: write
      actions: read
    steps:
      - name: ðŸ“¥ Checkout code
        uses: actions/checkout@v5
        with:
          fetch-depth: 0

      - name: ðŸ”§ Setup Go
        uses: actions/setup-go@v6
        with:
          go-version: ${{ needs.preflight.outputs.go-version }}
          cache: false

      - name: ðŸ“Š Submit dependency graph
        run: |
          # Generate go.sum if it doesn't exist
          go mod download
          go mod tidy

          # For dependency graph submission, we'll use GitHub's built-in Go support
          # which automatically detects go.mod and go.sum files

      - name: ðŸ“‹ Generate SBOM with Syft
        uses: anchore/sbom-action@v0
        with:
          path: .
          format: spdx-json
          output-file: go-toolbox-sbom.spdx.json
          upload-artifact: true
          upload-release-assets: ${{ startsWith(github.ref, 'refs/tags/') }}

      - name: ðŸ”’ Run vulnerability scan with govulncheck
        run: |
          go install golang.org/x/vuln/cmd/govulncheck@latest
          govulncheck ./...

      - name: ðŸ“¦ Archive SBOM artifacts
        uses: actions/upload-artifact@v4
        with:
          name: sbom-reports
          path: |
            *.spdx.json
            *.sarif
          retention-days: 30

  # Build the embedded application (contains all tools)
  build-embedded:
    name: ðŸš€ Build Embedded Application
    needs: preflight
    runs-on: ubuntu-latest
    strategy:
      matrix:
        include:
          - goos: linux
            goarch: amd64
          - goos: linux
            goarch: arm64
          - goos: windows
            goarch: amd64
          - goos: darwin
            goarch: amd64
          - goos: darwin
            goarch: arm64

    steps:
      - name: ðŸ“¥ Checkout code
        uses: actions/checkout@v5

      - name: ðŸ”§ Set up Go
        uses: actions/setup-go@v6
        with:
          go-version: ${{ needs.preflight.outputs.go-version }}
          cache: false # We'll handle caching manually for better control

      - name: ðŸ”§ Configure Go cache directories for embedded
        run: |
          # Create unique workspace identifier for this embedded matrix job
          MATRIX_ID="embedded-${{ matrix.goos }}-${{ matrix.goarch }}-${{ github.run_id }}-${{ github.run_attempt }}"

          # Set unique cache directories for this embedded matrix job
          export GOCACHE="$HOME/.cache/go-build-${MATRIX_ID}"
          export GOMODCACHE="$HOME/go/pkg/mod-${MATRIX_ID}"
          export GOPATH="$HOME/go-${MATRIX_ID}"
          export GOBIN="${GOPATH}/bin"

          echo "GOCACHE=${GOCACHE}" >> $GITHUB_ENV
          echo "GOMODCACHE=${GOMODCACHE}" >> $GITHUB_ENV
          echo "GOPATH=${GOPATH}" >> $GITHUB_ENV
          echo "GOBIN=${GOBIN}" >> $GITHUB_ENV
          echo "MATRIX_ID=${MATRIX_ID}" >> $GITHUB_ENV

          mkdir -p "${GOCACHE}" "${GOMODCACHE}" "${GOPATH}" "${GOBIN}"

          echo "âœ… Embedded Go cache directories configured for matrix job ${MATRIX_ID}:"
          echo "  GOCACHE: ${GOCACHE}"
          echo "  GOMODCACHE: ${GOMODCACHE}"
          echo "  GOPATH: ${GOPATH}"
          echo "  GOBIN: ${GOBIN}"

      - name: Cache Go modules
        uses: actions/cache@v4
        with:
          path: |
            ~/go/pkg/mod-embedded-${{ matrix.goos }}-${{ matrix.goarch }}-${{ github.run_id }}-${{ github.run_attempt }}
            ~/.cache/go-build-embedded-${{ matrix.goos }}-${{ matrix.goarch }}-${{ github.run_id }}-${{ github.run_attempt }}
            ~/go-embedded-${{ matrix.goos }}-${{ matrix.goarch }}-${{ github.run_id }}-${{ github.run_attempt }}
          key: ${{ needs.preflight.outputs.cache-key }}-embedded-${{ matrix.goos }}-${{ matrix.goarch }}-${{ github.run_id }}-${{ github.run_attempt }}
          restore-keys: |
            ${{ env.CACHE_VERSION }}-${{ runner.os }}-go-${{ env.GO_VERSION }}-embedded-${{ matrix.goos }}-${{ matrix.goarch }}-
            ${{ env.CACHE_VERSION }}-${{ runner.os }}-go-${{ env.GO_VERSION }}-

      - name: ðŸ“¦ Download dependencies
        run: go mod download

      - name: ðŸš€ Build embedded application
        env:
          GOOS: ${{ matrix.goos }}
          GOARCH: ${{ matrix.goarch }}
          VERSION: ${{ needs.preflight.outputs.version }}
        run: |
          echo "ðŸš€ Building embedded application for ${{ matrix.goos }}/${{ matrix.goarch }}..."

          mkdir -p bin

          # Build the embedded application
          OUTPUT_NAME="go-toolbox-embedded-${{ matrix.goos }}-${{ matrix.goarch }}"
          if [ "${{ matrix.goos }}" == "windows" ]; then
            OUTPUT_NAME="${OUTPUT_NAME}.exe"
          fi

          go build -ldflags="-s -w -X main.appVersion=${VERSION}" \
            -o "bin/${OUTPUT_NAME}" \
            ./cmd/embedded

          echo "âœ… Built: bin/${OUTPUT_NAME}"
          ls -la bin/

      - name: ðŸ“¤ Upload embedded artifacts
        uses: actions/upload-artifact@v4
        with:
          name: embedded-${{ matrix.goos }}-${{ matrix.goarch }}
          path: bin/
          retention-days: 30

  # Create release packages
  package:
    name: ðŸ“¦ Create Release Packages
    needs: [preflight, test, build-embedded]
    runs-on: ubuntu-latest
    if: needs.preflight.outputs.is-release == 'true'

    steps:
      - name: ðŸ“¥ Checkout code
        uses: actions/checkout@v5

      - name: ðŸ“¥ Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts

      - name: ðŸ“¦ Create release packages
        run: |
          echo "ðŸ“¦ Creating release packages..."
          mkdir -p release-packages

          # Create packages for each platform
          for platform_dir in artifacts/binaries-*; do
            if [ ! -d "$platform_dir" ]; then continue; fi
            
            platform=$(basename "$platform_dir" | sed 's/binaries-//')
            echo "Processing platform: $platform"
            
            # Create CLI package
            cli_package="go-toolbox-cli-${platform}"
            mkdir -p "temp/$cli_package"
            
            # Copy CLI binaries
            if [ -d "$platform_dir/bin" ]; then
              cp -r "$platform_dir/bin"/* "temp/$cli_package/" 2>/dev/null || true
            fi
            
            # Add README and LICENSE
            cp README.md LICENSE "temp/$cli_package/" 2>/dev/null || true
            
            # Create archive
            cd temp
            if [[ "$platform" == *"windows"* ]]; then
              zip -r "../release-packages/${cli_package}.zip" "$cli_package"
            else
              tar -czf "../release-packages/${cli_package}.tar.gz" "$cli_package"
            fi
            cd ..
            rm -rf "temp/$cli_package"
          done

          # Create embedded packages
          for embedded_dir in artifacts/embedded-*; do
            if [ ! -d "$embedded_dir" ]; then continue; fi
            
            platform=$(basename "$embedded_dir" | sed 's/embedded-//')
            echo "Processing embedded platform: $platform"
            
            embedded_package="go-toolbox-embedded-${platform}"
            mkdir -p "temp/$embedded_package"
            
            # Copy embedded binary
            if [ -d "$embedded_dir/bin" ]; then
              cp -r "$embedded_dir/bin"/* "temp/$embedded_package/" 2>/dev/null || true
            fi
            
            # Add README and LICENSE
            cp README.md LICENSE "temp/$embedded_package/" 2>/dev/null || true
            
            # Create archive
            cd temp
            if [[ "$platform" == *"windows"* ]]; then
              zip -r "../release-packages/${embedded_package}.zip" "$embedded_package"
            else
              tar -czf "../release-packages/${embedded_package}.tar.gz" "$embedded_package"
            fi
            cd ..
            rm -rf "temp/$embedded_package"
          done

          echo "ðŸ“¦ Release packages created:"
          ls -la release-packages/

      - name: ðŸ“¤ Upload release packages
        uses: actions/upload-artifact@v4
        with:
          name: release-packages
          path: release-packages/
          retention-days: 90

  # Publish release
  publish:
    name: ðŸš€ Publish Release
    needs: [preflight, package]
    runs-on: ubuntu-latest
    if: needs.preflight.outputs.is-release == 'true' && github.ref_type == 'tag'

    steps:
      - name: ðŸ“¥ Checkout code
        uses: actions/checkout@v5
        with:
          fetch-depth: 0

      - name: ðŸ“¥ Download release packages
        uses: actions/download-artifact@v4
        with:
          name: release-packages
          path: release-packages

      - name: ðŸ“ Generate release notes
        id: release-notes
        run: |
          VERSION="${{ needs.preflight.outputs.version }}"
          echo "Generating release notes for $VERSION..."

          # Get the previous tag
          PREV_TAG=$(git describe --tags --abbrev=0 HEAD~1 2>/dev/null || echo "")

          # Generate changelog
          if [ -n "$PREV_TAG" ]; then
            echo "## ðŸš€ What's Changed" > release-notes.md
            echo "" >> release-notes.md
            git log --pretty=format:"- %s (%h)" $PREV_TAG..HEAD >> release-notes.md
            echo "" >> release-notes.md
          else
            echo "## ðŸš€ Initial Release" > release-notes.md
            echo "" >> release-notes.md
            echo "This is the initial release of Go Toolbox." >> release-notes.md
            echo "" >> release-notes.md
          fi

          echo "## ðŸ“¦ Release Assets" >> release-notes.md
          echo "" >> release-notes.md
          echo "### CLI Tools" >> release-notes.md
          echo "Choose the package for your platform:" >> release-notes.md
          echo "" >> release-notes.md

          # List CLI packages
          for file in release-packages/go-toolbox-cli-*; do
            if [ -f "$file" ]; then
              basename=$(basename "$file")
              platform=$(echo "$basename" | sed 's/go-toolbox-cli-//' | sed 's/\.[^.]*$//')
              echo "- **$platform**: $basename" >> release-notes.md
            fi
          done

          echo "" >> release-notes.md
          echo "### Embedded Application" >> release-notes.md
          echo "Single binary containing all tools:" >> release-notes.md
          echo "" >> release-notes.md

          # List embedded packages
          for file in release-packages/go-toolbox-embedded-*; do
            if [ -f "$file" ]; then
              basename=$(basename "$file")
              platform=$(echo "$basename" | sed 's/go-toolbox-embedded-//' | sed 's/\.[^.]*$//')
              echo "- **$platform**: $basename" >> release-notes.md
            fi
          done

          echo "" >> release-notes.md
          echo "## ðŸ”§ Installation" >> release-notes.md
          echo "" >> release-notes.md
          echo "1. Download the appropriate package for your platform" >> release-notes.md
          echo "2. Extract the archive" >> release-notes.md
          echo "3. Add the binaries to your PATH" >> release-notes.md
          echo "" >> release-notes.md
          echo "For the embedded version, you only need the single binary." >> release-notes.md

      - name: ðŸš€ Create GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ needs.preflight.outputs.version }}
          name: "Go Toolbox ${{ needs.preflight.outputs.version }}"
          body_path: release-notes.md
          draft: false
          prerelease: ${{ contains(needs.preflight.outputs.version, 'alpha') || contains(needs.preflight.outputs.version, 'beta') || contains(needs.preflight.outputs.version, 'rc') }}
          files: |
            release-packages/*
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: ðŸ“Š Release Summary
        run: |
          echo "## ðŸš€ Release Published Successfully!" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Version**: ${{ needs.preflight.outputs.version }}" >> $GITHUB_STEP_SUMMARY
          echo "**Release URL**: https://github.com/${{ github.repository }}/releases/tag/${{ needs.preflight.outputs.version }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ðŸ“¦ Published Assets:" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          for file in release-packages/*; do
            if [ -f "$file" ]; then
              echo "- $(basename "$file")" >> $GITHUB_STEP_SUMMARY
            fi
          done

  # Final cleanup and summary
  cleanup:
    name: ðŸ§¹ Cleanup & Summary
    needs: [preflight, test, build-embedded]
    runs-on: ubuntu-latest
    if: always()

    steps:
      - name: ðŸ“Š Workflow Summary
        run: |
          echo "## ðŸ”§ CI Pipeline Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Job | Status |" >> $GITHUB_STEP_SUMMARY
          echo "|-----|--------|" >> $GITHUB_STEP_SUMMARY
          echo "| Pre-flight | ${{ needs.preflight.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Test & Build | ${{ needs.test.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Build Embedded | ${{ needs.build-embedded.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Version**: ${{ needs.preflight.outputs.version }}" >> $GITHUB_STEP_SUMMARY
          echo "**Is Release**: ${{ needs.preflight.outputs.is-release }}" >> $GITHUB_STEP_SUMMARY

      - name: ðŸ§¹ Final cleanup notification
        run: |
          echo "ðŸ§¹ CI pipeline completed. Cleanup tasks:"
          echo "  âœ… Temporary files cleaned"
          echo "  âœ… Build artifacts uploaded"
          echo "  âœ… Test results preserved"
          echo "  âœ… Cache optimized for next run"
